# 630. 课程表 III（困难）#【贪心，优先队列】

标签（空格分隔）： in_order

---
这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。

给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。

示例：
    
    输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
    输出: 3
    解释: 
    这里一共有 4 门课程, 但是你最多可以修 3 门:
    首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。
    第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。
    第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
    第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。

提示:

    整数 1 <= d, t, n <= 10,000 。
    你不能同时修两门课程。

### 贪心+优先队列：
// 思路： 贪心， PriorityQueue    
// (1) 按照deadline从小到大排序, 先学习deadline靠前的不吃亏，理想情况下：所有前一门课的deadline和下一门课必须开始的的时间不相交，那么可以修所有的课，比如下面3门课：    
// [100, 200], [200, 400], [150, 500]    
// (2) 当要学习下一门课时，发现当前学习的天数(第几天) 加上 准备学习的这门课的持续时间，会超过准备学习这门课的deadline， 怎么办？    
// 肯定是把修过的课里面的持续时间最长的课程给去掉，对于本次来说加一个，去一个，是没有多修课程的；但是有可能多后续的就有收益，因为你去掉了最长的课程，    
// 这样就腾出了最多的空间。    
```c++
class Solution {
public:
    static bool Cmp(vector<int>& a, vector<int>& b){    //要加static
        return a[1] < b[1];
    }
    int scheduleCourse(vector<vector<int>>& courses) {
        sort(courses.begin(), courses.end(), Cmp);
        priority_queue<int, vector<int>> pq;

        int day = 0;
        for(int i = 0; i < courses.size(); i++){
            if(day + courses[i][0] <= courses[i][1]){
                pq.push(courses[i][0]);
                day += courses[i][0];
            }else{
                //先放进去，用于比较
                pq.push(courses[i][0]);
                day += courses[i][0];
                //把时间最长的拿出来
                day -= pq.top();
                pq.pop();
            }
        }
        return pq.size();
    }
};
```
